@top Program { literal* }

@skip { whitespace }

literal { Number }

Number { Rational | Float | Hex | Octal | Binary | Integer }

@tokens {
  @precedence {
    Rational Float Hex Octal Binary Integer
  }

  whitespace { @whitespace+ }

  Rational { signed<digits<@digit>> $[r/] digits<@digit> }
  Float { signed<@digit>+ "." @digit+ }
  Hex { prefixed<"0x", $[0-9a-fA-F]> }
  Octal { prefixed<"0o", $[0-7]> }
  Binary { prefixed<"0b", $[01]> }
  Integer { signed<digits<@digit>> }  
  digits<digit> { digit ($[\_ ]? digit)* }
  signed<digit> { "-"? digit}
  prefixed<prefix, digit> { signed<prefix digits<digit>> }


  //   Atom { unquotedAtom | quotedAtom }
//   unquotedAtom { lowerIdentifier }
//   quotedAtom { "'" ![\']+ "'" }

  // A fallback that matches any other character in case all
  // else fails. Needed to get a nice output and avoid strange
  // overlapping tokens!
  else { _ }
}



// @top Program { (Directive | clause | term)* }

// @precedence {
//   Fact,
//   term
// }

// Directive { ":-" term "." }


// term { Atom | Variable | number | compoundTerm }

// clause { Fact | Rule }

// number { Integer | Float | Rational }

// predicate { Atom | Variable | compoundTerm }

// Fact { predicate "." }
// Rule { predicate ":-" rules "." }

// rules { predicate (("," | ";") predicate)* }

// compoundTerm { CompoundTerm | String | List }
// CompoundTerm { Functor parameterList<term> }
// Functor { Atom }
// List { "[" commaSeparated<term> "]" }

// commaSeparated<content> {
//   "" | content ("," content?)*
// }

// parameterList<content> {
//   parenthesized<commaSeparated<content>>
// }

// parenthesizedOptional<content> {
//   parenthesized<content> | content
// }

// parenthesized<content> {
//   "(" content ")"
// }

// // @skip { whitespace }
// @skip { whitespace | LineComment }

// @tokens {
//   @precedence {
//     Rational,
//     Float,
//     Integer
//   }

//   whitespace { @whitespace+ }

//   String { '"' stringContent '"' }
//   stringContent { (HexEscapeChar | UnicodeEscapeChar | EscapeChar | RegularChar)* }

//   HexEscapeChar { "\\x" hexDigit hexDigit }
//   UnicodeEscapeChar { 
//     "\\u" hexDigit hexDigit hexDigit hexDigit |
//     "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
//   }
//   EscapeChar { "\\" $[abcefnrsv\\'"`] }
//   RegularChar { !["\\] }

//   LineComment { "%" ![\n]* }

//   Rational { signedInteger ("r" | "/") unsignedInteger }
//   Float { signedInteger "." unsignedInteger }
//   Integer { binaryInteger | octalInteger | hexInteger | signedInteger }

//   Cut { "!" } 

//   binaryInteger { "0b" binaryDigit+ }
//   binaryDigit { $[01] }
//   octalInteger { "0o" octalDigit+ }
//   octalDigit { $[0-7] }
//   hexInteger { "0x" hexDigit+ }
//   hexDigit { $[0-9a-fA-F] }

//   signedInteger { "-"? @digit digitGroup* }
//   unsignedInteger { @digit digitGroup* }

//   digitGroup { $[_ ]? @digit+ }

//   Atom { unquotedAtom | quotedAtom }
//   unquotedAtom { lowerIdentifier }
//   quotedAtom { "'" ![\']+ "'" }

//   Variable { upperIdentifier }

//   lowerIdentifier { @asciiLowercase identifierChar* }
//   upperIdentifier { (@asciiUppercase | "_") identifierChar* }
//   identifierChar { @asciiLetter | @digit | "_" }
// }

// @detectDelim

// // https://github.com/lezer-parser/generator/blob/d827142436db3724af4b4dd9162132ca343f34e0/src/node.ts#L303
