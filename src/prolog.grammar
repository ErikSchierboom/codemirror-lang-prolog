@top Program { (predicate | term)* }

@skip { whitespace | LineComment }

term { literal | compound | Atom | Variable | Cut }

literal { Number | String }
Number { Rational | Float | Hex | Octal | Binary | Integer }

@local tokens {  
  stringEnd[@name='"'] { '"' }
  stringEscape { HexChar | UnicodeChar | EscapeChar }
  @else stringContent
}

@skip {} {
  String { '"' (stringContent | stringEscape)* stringEnd }
}

predicate {
  Rule { Functor Arguments ~functor ":-" commaSep<term> "."} |  
  Directive { ":-" commaSep<term> "." } |
  Fact { Functor Arguments ~functor "." }  
}

compound { 
  List { "[" commaSep<term> "]" } |
  CompoundTerm { Functor Arguments ~functor }
}

Functor { Atom }
Arguments { parenthesized<commaSep<term>> }

parenthesized<content> { "(" content ")" }
commaSep<content> { "" | content ("," content)* }

@tokens {
  @precedence {
    Rational Float Hex Octal Binary Integer
  }

  whitespace { @whitespace+ }

  LineComment { "%" ![\n]* }

  Cut { "!" }

  HexChar { "\\x" hexDigit hexDigit }
  UnicodeChar { 
    "\\u" hexDigit hexDigit hexDigit hexDigit |
    "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
  }
  EscapeChar { "\\" $[abcefnrsv\\'"`] }

  Rational { signed<digits<@digit>> $[r/] digits<@digit> }
  Float { signed<@digit>+ "." @digit+ }
  Hex { prefixed<"0x", hexDigit> }
  Octal { prefixed<"0o", octalDigit> }
  Binary { prefixed<"0b", binaryDigit> }
  Integer { signed<digits<@digit>> }
  hexDigit { $[0-9a-fA-F] }
  octalDigit { $[0-7] }
  binaryDigit { $[01] }
  digits<digit> { digit ($[\_ ]? digit)* }
  signed<digit> { "-"? digit}
  prefixed<prefix, digit> { signed<prefix digits<digit>> }

  Atom {
    @asciiLowercase wordChar* |
    "'" ("\\'" | ![\\'])+ "'"
  }
  Variable { (@asciiUppercase | "_") wordChar* }
  wordChar { @asciiLetter | @digit | "_" }

  // A fallback that matches any other character in case all
  // else fails. Needed to get a nice output and avoid strange
  // overlapping tokens!
  else { _ }
}
