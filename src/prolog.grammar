@top Program { term* }

@skip { whitespace | LineComment }

term { literal | compound | Atom | Variable }

literal { Number | String }
Number { Rational | Float | Hex | Octal | Binary | Integer }

@local tokens {  
  stringEnd[@name='"'] { '"' }
  stringEscape { HexChar | UnicodeChar | EscapeChar }
  @else stringContent
}

@skip {} {
  String { '"' (stringContent | stringEscape)* stringEnd }
}

compound { List }
List { "[" commaSep<term> "]" }

commaSep<content> { "" | content ("," content)* }

@tokens {
  @precedence {
    Rational Float Hex Octal Binary Integer
  }

  whitespace { @whitespace+ }

  LineComment { "%" ![\n]* }

  HexChar { "\\x" hexDigit hexDigit }
  UnicodeChar { 
    "\\u" hexDigit hexDigit hexDigit hexDigit |
    "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
  }
  EscapeChar { "\\" $[abcefnrsv\\'"`] }

  Rational { signed<digits<@digit>> $[r/] digits<@digit> }
  Float { signed<@digit>+ "." @digit+ }
  Hex { prefixed<"0x", hexDigit> }
  Octal { prefixed<"0o", octalDigit> }
  Binary { prefixed<"0b", binaryDigit> }
  Integer { signed<digits<@digit>> }
  hexDigit { $[0-9a-fA-F] }
  octalDigit { $[0-7] }
  binaryDigit { $[01] }
  digits<digit> { digit ($[\_ ]? digit)* }
  signed<digit> { "-"? digit}
  prefixed<prefix, digit> { signed<prefix digits<digit>> }

  Atom {
    @asciiLowercase wordChar* |
    "'" ("\\'" | ![\\'])+ "'"
  }
  Variable { (@asciiUppercase | "_") wordChar* }
  wordChar { @asciiLetter | @digit | "_" }

  // A fallback that matches any other character in case all
  // else fails. Needed to get a nice output and avoid strange
  // overlapping tokens!
  else { _ }
}



// @top Program { (Directive | clause | term)* }

// @precedence {
//   Fact,
//   term
// }

// Directive { ":-" term "." }


// term { Atom | Variable | number | compoundTerm }

// clause { Fact | Rule }

// number { Integer | Float | Rational }

// predicate { Atom | Variable | compoundTerm }

// Fact { predicate "." }
// Rule { predicate ":-" rules "." }

// rules { predicate (("," | ";") predicate)* }

// compoundTerm { CompoundTerm | String | List }
// CompoundTerm { Functor parameterList<term> }
// Functor { Atom }
// List { "[" commaSeparated<term> "]" }

// commaSeparated<content> {
//   "" | content ("," content?)*
// }

// parameterList<content> {
//   parenthesized<commaSeparated<content>>
// }

// parenthesizedOptional<content> {
//   parenthesized<content> | content
// }

// parenthesized<content> {
//   "(" content ")"
// }


// @tokens {
//   Cut { "!" } 
// }

// @detectDelim

// // https://github.com/lezer-parser/generator/blob/d827142436db3724af4b4dd9162132ca343f34e0/src/node.ts#L303
